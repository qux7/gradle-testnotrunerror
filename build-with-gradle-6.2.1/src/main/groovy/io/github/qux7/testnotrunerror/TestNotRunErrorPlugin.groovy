/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package io.github.qux7.testnotrunerror

import org.gradle.api.GradleException
import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.tasks.testing.Test
import org.gradle.util.GradleVersion

import java.nio.file.Files
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import java.util.regex.Pattern

/**
 * Gradle plugin: report tests that were not run.
 */
public class TestNotRunErrorPlugin implements Plugin<Project> {
    static String classCheckErrorMessagePrefix = "Test classes are present but tests were not executed:"
    static String javaSourceCheckErrorMessagePrefix = "Java source files are present but tests were not executed:"
    static String testFilterDetected = "no error because --tests was specified on the command line"
    static String stopOnFailureDisabled = "no error because `testnotrunerror { stopOnFailure = false }` was specified"
    static String applyMessage = "APPLYING TestNotRunErrorPlugin: REPORT TESTS THAT WERE NOT RUN DUE TO A DEPENDENCY/CONFIGURATION ERROR"
    static String whenFailure_Message = "To treat errors as warnings, use 'testnotrunerror { stopOnFailure=false }' in the build script, or '-Ptestnotrunerror.stopOnFailure=false' on the command line"
    static String propertiesDocsUrl = "https://github.com/qux7/gradle-testnotrunerror#other-kinds-of-overrides"
    static String disabledInPrjPropMessage = "TestNotRunErrorPlugin was disabled via project properties, there are multiple ways to do that, see " + propertiesDocsUrl
    static String disabledInCfgMessage = "TestNotRunErrorPlugin was disabled with 'testnotrunerror { enabled = false }'";
    static String useWarningInstead_Message = "Use 'stopOnFailure=false' instead of 'enabled=false' to see error messages as warnings"
    static String extensionBeforeOverrides = "TestNotRunErrorPlugin extension before applying properties: "
    static String extensionAfterOverrides = "TestNotRunErrorPlugin extension after applying properties: "

    public void apply(Project project) {
        println(applyMessage)
        println("Gradle version: " + GradleVersion.current().version + "; Groovy version: " + GroovySystem.version + "; Java version: " + System.getProperty("java.version"));
        def extension = project.extensions.create("testnotrunerror", TestNotRunErrorPluginExtension)
        NamedDomainObjectContainer<TestTaskExcludeClassNames> perTaskExcludes = project.container(TestTaskExcludeClassNames)
        extension.extensions.excludes = perTaskExcludes

        project.tasks.withType(Test) {
            def runTestSet = ConcurrentHashMap.newKeySet()
            def testCount = new AtomicInteger();
            def exceptionMessage1 = ""
            def exceptionMessage2 = ""

            doFirst {
                project.logger.info(extensionBeforeOverrides + extension)
                boolean wasEnabled = extension.enabled
                extension.setFromProjectProperties(project)
                project.logger.info(extensionAfterOverrides + extension)
                if (!extension.enabled) {
                    println(wasEnabled ? disabledInCfgMessage : disabledInPrjPropMessage)
                    println(useWarningInstead_Message)
                }
            }

            afterTest { desc, res ->
                if (extension.enabled) {
                    runTestSet.add(desc.className);
                    testCount.incrementAndGet()
                }
            }

            doLast {
                if (extension.enabled) {
                    println("[$name] Total tests run: ${testCount.get()}")
                }
            }

            doLast {
                if (extension.enabled) {
                    Set<String> diffClasses = [], diffJava = []
                    if (extension.checkClasses) {
                        def compiledTestSet = getCompiledClassNames(testClassesDirs)
                        def excludes = perTaskExcludes?.findByName(name)?.excludeClassNames ?: []
                        diffClasses = compiledTestSet - runTestSet - excludes
                    }
                    if (extension.checkJavaSources) {
                        def javaDirs = project.sourceSets[name].java.srcDirs
                        def javaSourceTestSet = getClassNamesFromSources(javaDirs)
                        def excludes = perTaskExcludes?.findByName(name)?.excludeClassNames ?: []
                        diffJava = javaSourceTestSet - runTestSet - excludes
                    }
                    if (extension.readSourceFiles) {
                        def javaDirs = project.sourceSets[name].java.srcDirs
                        def toIgnore = getFilesMarkedToIgnore(javaDirs, diffClasses + diffJava)
                        diffClasses -= toIgnore
                        diffJava -= toIgnore
                    }
                    if (diffClasses) {
                        String msg = "[$name] $classCheckErrorMessagePrefix ${new TreeSet<>(diffClasses)}"
                        project.logger.error(msg)
                        exceptionMessage1 = msg
                    }
                    if (diffJava) {
                        String msg = "[$name] $javaSourceCheckErrorMessagePrefix ${new TreeSet<>(diffJava)}"
                        project.logger.error(msg)
                        exceptionMessage2 = msg
                    }
                }
            }

            doLast {
                if (extension.enabled) {
                    if (exceptionMessage1 || exceptionMessage2) {
                        if (filter.commandLineIncludePatterns) {
                            project.logger.error("[$name] $testFilterDetected")
                        } else if (!extension.stopOnFailure) {
                            project.logger.error("[$name] $stopOnFailureDisabled")
                        } else {
                            project.logger.error("[$name] $whenFailure_Message")
                            throw new GradleException([exceptionMessage1, exceptionMessage2].findAll().join("; "))
                        }
                    }
                }
            }
        }
    }

    /**
     * Knowing the directories where the compiled classes go, classesDirs,  find all their class names.
     * @param classesDirs a collection of directories with classes
     * @return a Set<String> of class names
     */
    static def getCompiledClassNames(classesDirs) {
        def testClassSet = ConcurrentHashMap.newKeySet()
        def sep = Pattern.quote(File.separator)
        classesDirs.findAll { it.exists() }.each {
            def dir = it.toString() + File.separator;
            it.eachFileRecurse {
                if (it ==~ /.*$sep[A-Za-z_][A-Za-z0-9_]*\.class/) {
                    testClassSet += (it.toString() - dir - '.class').replaceAll(sep, '.')
                }
            }
        }
        return testClassSet
    }

    /**
     * Knowing the directories where the Java sources are, javaDirs, find all corresponding class names.
     * @param javaDirs a collection of directories with java files
     * @return a Set<String> of class names
     */
    static def getClassNamesFromSources(javaDirs) {
        def testClassSet = ConcurrentHashMap.newKeySet()
        def sep = Pattern.quote(File.separator)
        javaDirs.findAll { it.exists() }.each {
            def dir = it.toString() + File.separator;
            it.eachFileRecurse {
                if (it ==~ /.*$sep[A-Za-z_][A-Za-z0-9_]*\.java/) {
                    testClassSet += (it.toString() - dir - '.java').replaceAll(sep, '.')
                }
            }
        }
        return testClassSet
    }

    /**
     * Knowing the directories where the Java sources are, javaDirs, find all class names mentioned in classNameSet
     * such that the corresponding source file contains "@test.not.run=ignore"
     * @param javaDirs
     * @param classNameSet
     * @return
     */
    static def getFilesMarkedToIgnore(javaDirs, classNameSet) {
        def dirs = javaDirs.findAll { it.exists() }
        classNameSet.findAll { className ->
            dirs.any { File dir ->
                def f = new File(dir, classNameToFileName(className, '.java'))
                f.exists() && isMarkedForIgnoring(f)
            }
        }
    }

    /**
     * Check if the file contents contain the string "@test.not.run=ignore", which means that if tests from the file
     * do not run, e.g. because there is no tests, this plugin must ignore it.
     * @param f file with source code
     * @return true if the file contains the string "@test.not.run=ignore"
     */
    static boolean isMarkedForIgnoring(File f) {
        Files.lines(f.toPath()).withCloseable {
            it.filter { it.contains("@test.not.run=ignore") }.findFirst()
        }
    }

    /**
     * Convert class name to Java source file name, e.g. classNameToFileName('foo.Bar', '.java) gives 'foo/Bar.java'.
     * Nested classes are not supported.
     * @param className full Java class name, e.g. 'foo.bar.Baz'
     * @param suffix file extension, including dot, e.g. '.java'
     * @return the corresponding file name
     */
    static String classNameToFileName(String className, String suffix) {
        className.replaceAll(Pattern.quote('.'), '/') + suffix
    }
}


